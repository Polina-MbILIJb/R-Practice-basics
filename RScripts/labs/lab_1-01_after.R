# Esly russkie bukvy ne otobrajautsa: File -> Reopen with encoding... UTF-8

# Используйте UTF-8 как кодировку по умолчанию!
# Установить кодировку в RStudio: Tools -> Global Options -> General, 
#  Default text encoding: UTF-8

# ..............................................................................
# Практикум на ЭВМ 4: Практика 1
# ..............................................................................


# 3. Простая арифметика --------------------------------------------------------

# сложим три числа
1 + 2 + 4

# любые другие арифметические операции
7 * 8

15 - 5

1 / 2

1 - 0.09

1 - 9*10^(-8)

1 - 9*10^(-9)      ### [1] 1    # 10^-8 и 10^-9: здесь проходит граница точности


# 4. Создание числового вектора ------------------------------------------------

# создадим вектор x из трёх элементов
x <- c(177, 152, 164)
x

x + 160            ### [1] 337 312 324                   # магия!

# если всё же надо сложить все элементы x с суммой чисел, можно так
x[1] + x[2] + x[3] + 160

# но лучше воспользоваться функцией суммирования
sum(160, x)


# 5. Просмотр структуры объекта ------------------------------------------------

str(x)

# x: 15 значений случ. величины N~(0, 1)
x <- rnorm(n = 15)
# y: такой же
y <- rnorm(n = 15)

# корреляция x и y
xy.corr <- cor.test(x, y)
str(xy.corr)                # смотрим структуру

y <- str(x)
y


# 6. Вызов справки -------------------------------------------------------------

help(str)

?str

??structure

RSiteSearch('structure')


# 7. Последовательности --------------------------------------------------------

#  seq() =======================================================================

-7:-5
-3:6

seq(from = 1, to = 8)

# названия аргументов from и to можно опускать:
seq(-7, -5)
seq(-5, -7)

seq(from = 1, to = 8, by = 2)

seq(from = 1, to = -8, by = -2)

seq(from = 1, to = 8, by = -2)

seq(8, 1, -2)


#  rep() =======================================================================

rep(c(1, 2), 7)        # первый аргумент: что повторяем, второй: сколько раз

# своё число повторений для каждого элемента
rep(c(35, 14, 8), 1:3)

# аргументы распознаются автоматически по типу
rep(1:2, c(2, 6))

# ключевое слово each
rep(1:2, each = 7)

# если задать начало, конец и число элементов,
#  интервал будет рассчитан автоматически:
seq(10, 15, length = 4)


# 8. Копирование и сравнение объектов ------------------------------------------

x <- c(177, 152, 164)
y <- x
y = x        # запись, аналогичная предыдущей

y

is.vector(y)

is.vector(y,"logical")   # тип: логический

is.vector(y,"numeric")   # тип: числовой

x -> z
z

y == x       ### [1] TRUE TRUE TRUE 

z == x       ### [1] TRUE TRUE TRUE 

y == 177     ### [1]  TRUE FALSE FALSE 

y == '177'   ### [1]  TRUE FALSE FALSE 

y == "177"   ### [1]  TRUE FALSE FALSE 

y
y + 1

y + '2'      ### Error in y + "2" : non-numeric argument to binary operator

y + "2"      ### Error in y + "2" : non-numeric argument to binary operator


# 9. Обращение к элементам вектора, преобразование типов -----------------------

y[1] == 177

y[2] == 177

y == c(177, 152)

y[3] <- 177
y == 177

y <- as.character(y)
is.vector(y, "numeric")
y

x[1] + x[2]     # вектор x содержит числа

y[1] + y[2]     # вектор y содержит символы

as.numeric(y[1]) + as.numeric(y[2]) # символы – в числа

z <- paste(y[1], y[2])
z

z <- paste(y[1], y[2], sep = "")
z

paste0(y[1], y[2])     # даёт тот же результат

z <- paste(y[1], y[2], sep = ";")
z

paste(x, y)

paste(x, c(11, 12))


# 10. Матрицы ------------------------------------------------------------------

# создать
a <- matrix(rep(x, 2), 2, 3)
a

A <- matrix(rep(x, 2), 2, 3, byrow = T)
A

# просмотреть размерность
dim(A)

# создать вектор w: повторить x дважды
w <- rep(x, 2)


# превратить w в матрицу: каждый столбец это x
dim(w) <- c(3, 2)
w

# транспонируем матрицу w
t(w)

rownames(w) <- c("obs1", "obs2", "obs3")
colnames(w) <- c("V1", "V2")
w

# немного об операциях с матрицами =============================================

# оператор *
w * w

# оператор %*%
w %*% t(w)

A <- matrix(c(1, 2, 3, 4, 5, 6), 2, 3)
A

B <- matrix(c(9, 8, 7, 6, 5, 4), 3, 2)
B

A%*%B
B%*%A


# 11. Просмотр списка и удаление объектов, создание класса ---------------------

# точка -- это просто часть имени объекта
x.label <- "Рост сотрудников"
x
x.label


# список всех объектов рабочей области
ls()

ls(pattern = "x")

# удалим некоторые объекты
rm(xy.correlation, z)

# создать список из двух объектов
mylist <- list(x = x, x.label = x.label)
mylist

# обратимся к элементу списка по номеру
mylist[[1]]

# обратимся к элементу списка по имени
mylist$x
mylist[['x']]

# можно хранить имя в переменной
myname <- 'x'
mylist[[myname]]


# Пользовательский класс =======================================================

# создать новый класс объектов «customVector»
#  в объект входят «слоты»: сам числовой вектор (val)
#  и его название (label)
my.Vector <- setClass("my.Vector", 
                      slots = c(val = "numeric",
                                label = "character"))

# создать объект нового класса
#  здесь  customVector() – уже конструктор класса
x1 <- my.Vector(val = x, label = x.label)

# просмотреть созданный объект
x1

# просмотреть структуру созданного объекта
str(x1)

# обратиться к слоту
x1@val
x1@label

# обратиться к элементу слота
x1@val[2]

# создание метода сложения с числом
setMethod("+", signature(e1 = "my.Vector", e2 = "numeric"), 
          function(e1, e2) e1@val + e2)

# использование метода
x1 + 42
42 + x1     # ошибка! не тот порядок аргументов

# метод для отображения
setMethod("show", 
          signature(object = "my.Vector"), 
          function(object) {print(object@label); 
              print(object@val)})

# проверяем, как теперь выводится содержимое x1
x1

# удалить лишние объекты
rm(a, A, B, mylist, myname, w, xy.corr, y)

# просмотреть список оставшихся объектов
ls()


# 12. Тип объекта: фрейм данных; импорт из .csv --------------------------------

# создание фрейма данных, импорт из .csv
dfLab <- read.csv("FGLab.csv", row.names = 1,
                  stringsAsFactors = F)

# просмотр структуры и содержимого
str(dfLab, vec.len = 2)
dfLab

# первые три значения в столбце «Размер майки»
dfLab$Размер.майки[1:3]

# замена элемент таблицы: нет встроенных проверок типа
dfLab$Размер.майки[1] <- 56   # собственно замена значения
str(dfLab, vec.len = 2)         # структура после замены

# меняем обратно
dfLab$Размер.майки[1] <- 'L'
dfLab$Размер.майки


# 13. Тип шкалы: порядковая; тип данных: фактор --------------------------------

# создать вектор test.f и заполнить его значениями
#  в порядковой шкале
test.f <- factor(3:5)
test.f

# проверка типа вектора test.f
is.numeric(test.f)
is.factor(test.f)

# столбец "Размер майки", данные в порядковой шкале
dfLab$Размер.майки <- ordered(dfLab$Размер.майки,
                              levels = c("XS", "S", "M", "L", "XL", "XXL"))

# просмотр структуры фрейма
str(dfLab, vec.len = 2)


# 14. Выбор отдельных столбцов и строк фрейма данных ---------------------------

# оставить только столбцы «Имя» и «Возраст»
keep <- c("Имя", "Возраст")
dfLab[, keep, drop = FALSE]

# подвыборки из таблицы
dfLab[3, 1]
dfLab[3:5, 1:2]
dfLab[c(1, 4), c(1, 5)]
dfLab[c(-1, -6), -3:-7]
dfLab[dfLab$Возраст >= 18, c(1, 5)] 

# просмотр начала/конца таблицы
head(dfLab, n = 2)
tail(dfLab, n = 3)


# 15. Некоторые математические функции R ---------------------------------------

DF1 <- data.frame(v1 = c(1, 2, 3), v2 = c(4, 5, 6),
                  v3 = c(10, 20, 30))

# параллельные минимум и максимум
pmin(DF1[, 1], DF1[, 2], DF1[, 3])
pmax(DF1[, 1], DF1[, 2], DF1[, 3])

# то же самое функцией apply
apply(DF1, 1, min)
apply(DF1, 1, max)


# 16. Расчёт описательных статистик --------------------------------------------

summary(dfLab, digits = 0)

# работаем с вектором значений роста
x <- dfLab$Рост

# среднее арифметическое
mean(x)
# медиана
median(x)     
# вектор из 2 значений: минимум и максимум
range(x)      
# вектор накопленных сумм элементов
cumsum(x)     
# вектор накопленных произведений элементов
cumprod(x)    
# дисперсия
var(x)
# квантили заданных вероятностей
quantile(x, c(25, 75)/100)
