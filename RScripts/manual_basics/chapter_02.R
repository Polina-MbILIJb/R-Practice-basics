#
# Скрипт для учебного пособия "Введение в R"
#
# Суязова (Аксюк) Светлана Андреевна s.a.askuk@gmail.com
# версия скрипта: 1.0 (20.09.2018)
#
# версия R:
# R.version
###                _                           
### platform       x86_64-w64-mingw32          
### arch           x86_64                      
### os             mingw32                     
### system         x86_64, mingw32             
### status                                     
### major          3                           
### minor          5.1                         
### year           2018                        
### month          07                          
### day            02                          
### svn rev        74947                       
### language       R                           
### version.string R version 3.5.1 (2018-07-02)
### nickname       Feather Spray       


# 2. Виды объектов и типы данных -----------------------------------------------


# 2.1 Последовательности =======================================================

-3:6

seq(from = 1, to = 8)

# названия аргументов from и to можно опускать:
seq(-7, -5)
seq(-5, 1)

seq(from = 1, to = 8, by = 2)

# будьте внимательны с отрицательным by
seq(from = 1, to = 8, by = -2)
seq(8, 1, -2)        # теперь верно: from > to

seq(10, 15, length = 4)

# повторить вектор (1, 2) 3 раза
rep(c(35, 14, 8), 3)
# своё число повторений для каждого элемента
rep(c(35, 14, 8), 1:3)
# аргументы распознаются автоматически по порядку
rep(1:2, c(2, 6))
# ключевое слово each: повторить каждый элемент трижды
rep(c(35, 14, 8), each = 3)


# 2.2 Копирование и сравнение объектов =========================================

x <- c(177, 152, 164)    # снова сохраняем рост сотрудников
y <- x
y = x    # запись, аналогичная предыдущей

y
is.vector(y)             # y – это вектор
is.vector(y,"logical")   # тип вектора: логический
is.vector(y,"numeric")   # тип вектора: числовой

# так тоже можно, но не нужно
x -> z                   # присвоить z значение x
z

y == x
z == x

y == 177

y %in% c(177, 164)

y == '177'
y == "177"

y
y + 1
y + '2'

y

# 2.3 Обращение к элементам вектора, преобразование типов ======================

y[1] == 177
y[2]

y[3] <- 177
y

y <- as.character(y)
is.vector(y, "numeric")      # проверяем результат
y

x[1] + x[2]     # вектор x содержит числа
y[1] + y[2]     # вектор y содержит символы

as.numeric(y[1]) + as.numeric(y[2]) # символы – в числа

paste(y[1], y[2])
paste(y[1], y[2], sep = "")
paste0(y[1], y[2])           # даёт тот же результат, что sep = ""
paste(y, collapse = ";")     # склеить все элементы вектора

paste(x, y)

paste0(c(1, 2, 3, 4, 5, 6, 7), c('A', 'B', 'C'))


# 2.4 Матрицы ==================================================================

x
a <- matrix(rep(x, 2), 2, 3)
a

A <- matrix(rep(x, 2), 2, 3, byrow = T)    # заполняем построчно
A

# просмотреть размерность матрицы A
dim(A)

# создать вектор w – копию x
w <- rep(x, 2)
dim(w) <- c(3, 2)     # задать размерность вектора z...
w                     # ...что превращает его в матрицу

t(w)                        # транспонирование

rownames(w) <- c("obs1", "obs2", "obs3")
colnames(w) <- c("V1", "V2")
w

# оператор * перемножает соответствующие элементы
w * w

# матричное умножение, результат w^2
w.sq <- w %*% t(w) 
w.sq

# главная диагональ
diag(w.sq)
# треугольник под главной диагональю: логические флаги
lower.tri(w.sq)
# треугольник над главной диагональю: значения матрицы
w.sq[upper.tri(w.sq)]
# обнулить всё, кроме верхнего треугольника
w.sq[!upper.tri(w.sq)] <- 0
w.sq

# создадим квадратную матрицу
m.sq <- matrix(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 3, 3, byrow = T)
m.sq
# найдём обратную матрицу
solve(m.sq)


# 2.5 Просмотр списка и удаление объектов, создание класса =====================

x.label <- "Рост сотрудников"
x
x.label

ls()
ls(pattern = "x")

# удалим некоторые объекты
rm(a, A, m.sq, w, w.sq, xy.correlation, z)

# создать список из двух объектов
mylist <- list(x = x, x.label = x.label)
# посмотреть результат
mylist

# имя_списка$имя_объекта
mylist$x

# список из двух элементов
mylist.2 <- list(aaa = 1:5, bbb = letters[1:5])
mylist.2$aaa

mylist.2[[1]]  # обратиться по номеру
mylist.2[['bbb']]  # обратиться по имени

subv <- 'bbb'      # можно хранить имя в переменной
mylist.2[[subv]]

# создать новый класс объектов «customVector»
#  в объект входят «слоты»: сам числовой вектор (val)
#  и его название (label)
customVector <- setClass("customVector",
                         slots = c(val = "numeric",
                                   label = "character"))

# создать объект нового класса
#  здесь  customVector() – уже конструктор класса
x1 <- customVector(val = x, label = x.label)

# просмотреть созданный объект
x1
# просмотреть структуру созданного объекта
str(x1)

x1@val
x1@label
# слот val – вектор, можно обратиться к его элементу
x1@val[2]

# создание метода сложения с числом
setMethod("+", signature(e1 = "customVector", e2 = "numeric"), 
          function(e1, e2) e1@val + e2)
# использование метода
x1 + 42

setMethod("show", signature(object="customVector"), 
          function(object) {print(object@label); 
              print(object@val)})
# проверяем, как теперь выводится содержимое x1
x1

# удалить ненужные объекты
rm(mylist, mylist.2, subv, y)

# просмотреть список оставшихся объектов
ls()
### [1] "customVector"      "x"      "x1"      "x.label"

# удалить всё
rm(list = ls())
ls()


# 2.6 Класс объекта: фрейм данных; импорт из .csv ==============================

# импорт фрейма данных из .csv
dfLab <- read.table("FGLab.csv", header = T, sep = ",", 
                    dec = ".", stringsAsFactors = F, row.names = 1)

# то же самое с помощью read.csv()
dfLab <- read.csv("FGLab.csv", stringsAsFactors = F, row.names = 1)

# просмотр результата
dfLab

# просмотр структуры фрейма
str(dfLab, vec.len = 2)

# графический редактор
dfLab <- edit(dfLab)

# первые три значения в столбце «Размер майки»
dfLab$Размер.майки[1:3]

# фрейм до внесения изменений
str(dfLab, vec.len = 2)
dfLab$Размер.майки[1] <- 56   # собственно замена значения
str(dfLab, vec.len = 2)         # структура после замены

# меняем обратно
dfLab$Размер.майки[1] <- 'L'
dfLab$Размер.майки


# 2.7 Тип шкалы: порядковая; тип данных: фактор ================================

# столбец "Размер майки", данные в порядковой шкале
dfLab$Размер.майки <- ordered(dfLab$Размер.майки,
                              levels = c("XS", "S", "M", "L", "XL", "XXL"))

# просмотр структуры фрейма
str(dfLab, vec.len = 2)

# значения размеров маек
table(dfLab$Размер.майки)

# создать фактор из числового вектора
test.f <- as.factor(c(3, 2, 1, 3, 2, 2))
test.f
# можно добавить существующий уровень фактора
test.f[1] <- 2
test.f

# создать фактор из символьного вектора
test.f <- factor(dfLab$Имя)
test.f
# нельзя добавить новый уровень фактора
test.f[1] <- 'Киситани Синра'            # ошибка


# 2.8 Выбор отдельных столбцов и строк фрейма данных ===========================

# оставить только столбцы «Имя» и «Возраст»
keep <- c('Имя', 'Возраст')
# посмотреть результат
dfLab[, keep, drop = FALSE]

# элемент в третьей строке, первом столбце фрейма
dfLab[3, 1]
# строки с 3 по 5, столбцы с 1 по 2
dfLab[3:5, 1:2]
# строки 1 и 4, столбцы 1 и 5
dfLab[c(1, 4), c(1, 5)]
# строки без 1 и 6, столбцы без 1 и 5
dfLab[c(-1, -6), -3:-7] 
# сотрудники не младше 18
dfLab[dfLab$Возраст >= 18, c(1, 5)]   
# сотрудники-мужчины старше 16
dfLab[dfLab$Пол == 'муж' & dfLab$Возраст > 16, c(1, 2, 5)]   

head(dfLab)			     	# первые несколько строк
tail(dfLab, n = 3)			# последние три строки


# 2.9 Расчёт описательных статистик ============================================

summary(dfLab, digits = 0)

x <- dfLab$Рост
# среднее арифметическое
mean(x)
# медиана
median(x)
# вектор из 2 значений: минимум и максимум
range(x)
# вектор накопленных сумм элементов
cumsum(x)
# дисперсия
var(x)
# квантили заданных вероятностей
quantile(x, c(25, 75)/100)

# какие из столбцов фрейма числовые?
lapply(dfLab, is.numeric)
# то же в виде вектора
sapply(dfLab, is.numeric)

# выбираем только числовые столбцы
dfLab[, sapply(dfLab, is.numeric)]
# среднее по числовым столбцам
sapply(dfLab[, sapply(dfLab, is.numeric)], mean)
# среднее по числовым столбцам
apply(dfLab[, sapply(dfLab, is.numeric)], 2, mean)
# среднее по числовым строкам
apply(dfLab[, sapply(dfLab, is.numeric)], 1, mean)
